(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[18],{"1FpO":function(e,t,n){"use strict";n.r(t);var a=n("3Nsx"),c=n.n(a),l=n("WTS6"),r=n("JuRz"),o=c.a.memo((e=>{e.demos;return c.a.createElement(c.a.Fragment,null,c.a.createElement("div",{className:"markdown"},c.a.createElement("h1",{id:"react-hooks--react-refreshhmr"},c.a.createElement(l["AnchorLink"],{to:"#react-hooks--react-refreshhmr","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"React Hooks & react-refresh\uff08HMR\uff09"),c.a.createElement("h2",{id:"what-is-react-refresh"},c.a.createElement(l["AnchorLink"],{to:"#what-is-react-refresh","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"What is react-refresh?"),c.a.createElement("p",null,c.a.createElement(l["Link"],{to:"https://github.com/pmmmwh/react-refresh-webpack-plugin"},"react-refresh-webpack-plugin")," is a hot module replacement (HMR) plugin provided by React."),c.a.createElement("blockquote",null,c.a.createElement("p",null,'A Webpack plugin to enable "Fast Refresh" (also previously known as Hot Reloading) for React components.')),c.a.createElement("p",null,"In the development, react-refresh can keep state in component, and only change the edited part. In ",c.a.createElement(l["Link"],{to:"https://umijs.org/zh-CN/docs/fast-refresh"},"umi"),", can enable this feature by config ",c.a.createElement("code",null,"fastRefresh: ","{","}"),"."),c.a.createElement("p",null,c.a.createElement("img",{src:"https://camo.githubusercontent.com/244b53f735f2a78cfbce79a3914600840cdedac545e5f309d32ac7be4fdb2517/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f6769662f3138393335302f313632303631353937363932382d33633832353564642d396165342d343933342d613833322d3965643934636565353762632e67696623636c69656e7449643d7563376235663533362d656661652d342666726f6d3d64726f702669643d753234363633316564266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d666173742d726566726573682e676966266f726967696e4865696768743d363136266f726967696e57696474683d31303030266f726967696e616c547970653d62696e6172792673697a653d35313534393234267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7565316263613762312d393035362d343431392d613438382d6231393365366236643936",alt:"fast-refresh.gif"})),c.a.createElement("p",null,"This gif shows the development experience of using the react-refresh. After edit some code, the username and password that have been filled in remain unchanged, only the edited part has been changed."),c.a.createElement("h2",{id:"simple-principles-of-react-refresh"},c.a.createElement(l["AnchorLink"],{to:"#simple-principles-of-react-refresh","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"Simple Principles of react-refresh"),c.a.createElement("p",null,"For the Class component, react-refresh are always refresh (remount), existing state will be reset. For function components, react-refresh retains the existing state. Therefore, react-refresh provides a better experience for function components."),c.a.createElement("p",null,"This article mainly explains the weird behavior of React Hooks in react-refresh mode. Now let us look at the working mechanism of react-refresh on function components."),c.a.createElement("ul",null,c.a.createElement("li",null,"To maintain the state during hot replacement, the value of ",c.a.createElement("code",null,"useState")," and ",c.a.createElement("code",null,"useRef")," will not update."),c.a.createElement("li",null,"During hot replacement, ",c.a.createElement(l["AnchorLink"],{to:"(https://github.com/facebook/react/issues/21019#issuecomment-800650091)"},"To avoid some problems"),", ",c.a.createElement("code",null,"useEffect"),"\u3001",c.a.createElement("code",null,"useCallback"),"\u3001",c.a.createElement("code",null,"useMemoRun")," will re-executed.")),c.a.createElement("blockquote",null,c.a.createElement("p",null,'When we update the code, we need to "clean up" the effects that hold onto past values (e.g. passed functions), and "setup" the new ones with updated values. Otherwise, the values used by your effect would be stale and "disagree" with value used in your rendering, which makes Fast Refresh much less useful and hurts the ability to have it work with chains of custom Hooks.')),c.a.createElement("p",null,c.a.createElement("img",{src:"https://camo.githubusercontent.com/d9452c7cb9035fd422d9be908d1815ad25f0ca496d938fc3962d317c6d29fc61/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f6769662f3138393335302f313632303631383030393232392d63656261323438342d656430612d343336392d393731612d3636353931383933313238642e67696623636c69656e7449643d7563376235663533362d656661652d342666726f6d3d64726f702669643d753737313339373665266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d4b617074757265253230323032312d30352d3130253230617425323031312e33372e35342e676966266f726967696e4865696768743d383736266f726967696e57696474683d31323534266f726967696e616c547970653d62696e6172792673697a653d31373038383131267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7561343663386239322d656234342d343862372d383634352d3738323232623438646464",alt:"Kapture 2021-05-10 at 11.37.54.gif"})),c.a.createElement("p",null,"As shown in the gif, after the text is modified, ",c.a.createElement("code",null,"state")," remains unchanged and ",c.a.createElement("code",null,"useEffect")," is executed again."),c.a.createElement("h2",{id:"problem-caused-by-react-refresh"},c.a.createElement(l["AnchorLink"],{to:"#problem-caused-by-react-refresh","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"Problem caused by react-refresh"),c.a.createElement("p",null,"Under the above working mechanism, there will be many problems. Next, I will give a few specific examples."),c.a.createElement("h3",{id:"first-problem"},c.a.createElement(l["AnchorLink"],{to:"#first-problem","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"First problem"),c.a.createElement(r["a"],{code:"import React, { useEffect, useState } from 'react';\n\nexport default () => {\n  const [count, setState] = useState(0);\n\n  useEffect(() => {\n    setState((s) => s + 1);\n  }, []);\n\n  return <div>{count}</div>;\n};",lang:"js"}),c.a.createElement("p",null,"The above code is very simple. In normal mode, the maximum value of ",c.a.createElement("code",null,"count")," is ",c.a.createElement("code",null,"1"),". Because ",c.a.createElement("code",null,"useEffect")," will only be executed once during initialization."),c.a.createElement("p",null,"But in the react-refresh mode, the ",c.a.createElement("code",null,"state")," does not change every time it is hot updated, but the re-execution of ",c.a.createElement("code",null,"useEffect")," will cause the value of ",c.a.createElement("code",null,"count")," to keep increasing."),c.a.createElement("p",null,c.a.createElement("img",{src:"https://camo.githubusercontent.com/82528f255af3a88133d66824de55dd1f6e665030caf0bae81291951d5fe75943/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f6769662f3138393335302f313632303631393831313739312d34383161323862302d396262642d343938302d626635322d3731313561633336363262352e67696623636c69656e7449643d7563376235663533362d656661652d342666726f6d3d64726f702669643d753263313732313030266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d4b617074757265253230323032312d30352d3130253230617425323031322e30392e34372e676966266f726967696e4865696768743d383736266f726967696e57696474683d31323534266f726967696e616c547970653d62696e6172792673697a653d31333532383932267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7533346432653861302d333430642d346638632d383039302d6232346638303433623266",alt:"Kapture 2021-05-10 at 12.09.47.gif"})),c.a.createElement("p",null,"As shown in the gif, ",c.a.createElement("code",null,"count")," increases with each hot replacement."),c.a.createElement("h3",{id:"second-problem"},c.a.createElement(l["AnchorLink"],{to:"#second-problem","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"Second problem"),c.a.createElement("p",null,"If you used ",c.a.createElement(l["Link"],{to:"https://github.com/alibaba/hooks/blob/release/v2.x/packages/hooks/src/useUpdateEffect/index.ts"},"ahooks v2")," or ",c.a.createElement(l["Link"],{to:"https://github.com/streamich/react-use/blob/master/docs/useUpdateEffect.md"},"react-use")," ",c.a.createElement("code",null,"useUpdateEffect")," will also have unexpected behavior in HMR."),c.a.createElement(r["a"],{code:"import React, { useEffect } from 'react';\nimport useUpdateEffect from './useUpdateEffect';\n\nexport default () => {\n  useEffect(() => {\n    console.log('useEffect');\n  }, []);\n\n  useUpdateEffect(() => {\n    console.log('useUpdateEffect');\n  }, []);\n\n  return <div>hello world</div>;\n};",lang:"javascript"}),c.a.createElement("p",null,"Compared with ",c.a.createElement("code",null,"useEffect"),", ",c.a.createElement("code",null,"useUpdateEffect")," ignores the first execution and only executes when the deps changes. In the normal mode of the above code, ",c.a.createElement("code",null,"useUpdateEffect")," will never be executed, because deps is an empty array and will never change. But in react-refresh mode, during HMR, ",c.a.createElement("code",null,"useUpdateEffect")," and ",c.a.createElement("code",null,"useEffect")," are executed at the same time."),c.a.createElement("p",null,c.a.createElement("img",{src:"https://camo.githubusercontent.com/18000e2859234c5ca4d7613985dab82cba0a654cca53a9df5bc63dfcd126cce7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f6769662f3138393335302f313632303632303739373138392d36613561366434302d616637372d343339642d616462632d3230666430343664636663302e67696623636c69656e7449643d7563376235663533362d656661652d342666726f6d3d64726f702669643d753065323737343631266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d4b617074757265253230323032312d30352d3130253230617425323031322e32362e31392e676966266f726967696e4865696768743d383736266f726967696e57696474683d31323534266f726967696e616c547970653d62696e6172792673697a653d373937383135267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7564613336343363622d386435312d346437322d626461322d3362333431353762313530",alt:"Kapture 2021-05-10 at 12.26.19.gif"})),c.a.createElement("p",null,"The reason for this problem is that ",c.a.createElement("code",null,"useUpdateEffect")," uses ",c.a.createElement("code",null,"ref")," to record whether it is currently executed for the first time, see the code below."),c.a.createElement(r["a"],{code:"import { useEffect, useRef } from 'react';\n\nconst useUpdateEffect: typeof useEffect = (effect, deps) => {\n  const isMounted = useRef(false);\n\n  useEffect(() => {\n    if (!isMounted.current) {\n      isMounted.current = true;\n    } else {\n      return effect();\n    }\n  }, deps);\n};\n\nexport default useUpdateEffect;",lang:"javascript"}),c.a.createElement("p",null,"The key of the above code is ",c.a.createElement("code",null,"isMounted"),"."),c.a.createElement("ul",null,c.a.createElement("li",null,"During initialization, after the ",c.a.createElement("code",null,"useEffect")," is executed, the ",c.a.createElement("code",null,"isMounted")," is changed to ",c.a.createElement("code",null,"true")),c.a.createElement("li",null,"After the HMR, when the ",c.a.createElement("code",null,"useEffect")," is re-executing, because the ",c.a.createElement("code",null,"isMounted")," is already ",c.a.createElement("code",null,"true"),", so the whole effect is executed again.")),c.a.createElement("h3",{id:"third-problem"},c.a.createElement(l["AnchorLink"],{to:"#third-problem","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"Third problem"),c.a.createElement("p",null,"The first time discovered this problem is the ",c.a.createElement("code",null,"useRequest")," of ahooks, after HMR, the ",c.a.createElement("code",null,"loading")," would always be ",c.a.createElement("code",null,"true"),". After an inspection, the reason is use the ",c.a.createElement("code",null,"isUnmount")," ref to mark whether the component is unmount."),c.a.createElement(r["a"],{code:"import React, { useEffect, useState } from 'react';\n\nfunction getUsername() {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve('test');\n    }, 1000);\n  });\n}\n\nexport default function IndexPage() {\n  const isUnmount = React.useRef(false);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    setLoading(true);\n    getUsername().then(() => {\n      if (isUnmount.current === false) {\n        setLoading(false);\n      }\n    });\n    return () => {\n      isUnmount.current = true;\n    };\n  }, []);\n\n  return loading ? <div>loading</div> : <div>hello world</div>;\n}",lang:"javascript"}),c.a.createElement("p",null,"As the code above, during the hot replacement, ",c.a.createElement("code",null,"isUnmount.current")," becomes ",c.a.createElement("code",null,"true"),", causing the code to think that the component has been unmounted during the second execution."),c.a.createElement("h2",{id:"how-to-solve-these-problems"},c.a.createElement(l["AnchorLink"],{to:"#how-to-solve-these-problems","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"How to solve these problems"),c.a.createElement("h3",{id:"first-solution"},c.a.createElement(l["AnchorLink"],{to:"#first-solution","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"First solution"),c.a.createElement("p",null,"The first solution is to solve it from the code, that is, when we write code, we can always remember the weird behavior in react-refresh mode."),c.a.createElement("p",null,"For example, with ",c.a.createElement("code",null,"useUpdateEffect"),", we can initialize the ",c.a.createElement("code",null,"isMounted")," ref during initialization or hot replacement. as follows:"),c.a.createElement(r["a"],{code:"import { useEffect, useRef } from 'react';\n\nconst useUpdateEffect: typeof useEffect = (effect, deps) => {\n  const isMounted = useRef(false);\n\n+  useEffect(() => {\n+  \tisMounted.current = false;\n+  }, []);\n\n  useEffect(() => {\n    if (!isMounted.current) {\n      isMounted.current = true;\n    } else {\n      return effect();\n    }\n  }, deps);\n};\n\nexport default useUpdateEffect;",lang:"diff"}),c.a.createElement("p",null,"This solution is effective for both questions 2 and 3 above."),c.a.createElement("h3",{id:"second-solution"},c.a.createElement(l["AnchorLink"],{to:"#second-solution","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"Second solution"),c.a.createElement("p",null,"According to ",c.a.createElement(l["Link"],{to:"https://github.com/pmmmwh/react-refresh-webpack-plugin/blob/main/docs/API.md#reset"},"Official Document"),", we can solve this problem by adding the following comment in the file ."),c.a.createElement(r["a"],{code:"/* @refresh reset */",lang:"javascript"}),c.a.createElement("p",null,"After adding this question, every hot replacement will remount, that is, the component will be re-executed. ",c.a.createElement("code",null,"useState")," and ",c.a.createElement("code",null,"useRef")," will also be reset, so the above problem will not occur."),c.a.createElement("h2",{id:"official-attitude"},c.a.createElement(l["AnchorLink"],{to:"#official-attitude","aria-hidden":"true",tabIndex:-1},c.a.createElement("span",{className:"icon icon-link"})),"Official attitude"),c.a.createElement("p",null,"There are already many unspoken rules for React Hooks. When using react-refresh, there are still unspoken rules to pay attention to. But the official reply stated that this is expected behavior, see the ",c.a.createElement(l["Link"],{to:"https://github.com/facebook/react/issues/21019"},"issue"),"."),c.a.createElement("blockquote",null,c.a.createElement("p",null,'Effects are not exactly "mount"/"unmount" \u2014 they\'re more like "show"/"hide".'))))}));t["default"]=e=>{var t=c.a.useContext(l["context"]),n=t.demos;return c.a.useEffect((()=>{var t;null!==e&&void 0!==e&&null!==(t=e.location)&&void 0!==t&&t.hash&&l["AnchorLink"].scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),c.a.createElement(o,{demos:n})}}}]);