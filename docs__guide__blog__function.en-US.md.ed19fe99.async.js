(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[16],{fx22:function(e,t,n){"use strict";n.r(t);var a=n("3Nsx"),l=n.n(a),o=n("WTS6"),s=n("JuRz"),c=l.a.memo((e=>{e.demos;return l.a.createElement(l.a.Fragment,null,l.a.createElement("div",{className:"markdown"},l.a.createElement("h1",{id:"ahooks-function-specification"},l.a.createElement(o["AnchorLink"],{to:"#ahooks-function-specification","aria-hidden":"true",tabIndex:-1},l.a.createElement("span",{className:"icon icon-link"})),"ahooks function specification"),l.a.createElement("p",null,"ahooks tries its best to help everyone avoid the closure problem by specially processing the input and output functions."),l.a.createElement("p",null,l.a.createElement("strong",null,"1. All the output functions of ahooks, the references are stable")),l.a.createElement(s["a"],{code:"const [state, setState] = useState();",lang:"ts"}),l.a.createElement("p",null,"As we all know, the reference of the ",l.a.createElement("code",null,"setState")," function returned by ",l.a.createElement("code",null,"React.useState")," is fixed, and there is no need to consider weird problems when using it, and there is no need to put ",l.a.createElement("code",null,"setState")," in the dependencies of other Hooks."),l.a.createElement("p",null,"All functions returned by ahooks Hooks have the same characteristics as ",l.a.createElement("code",null,"setState"),", the reference will not change, just feel free to use it."),l.a.createElement("p",null,l.a.createElement("strong",null,"2. For all user input functions, always use the latest one")),l.a.createElement("p",null,"For the received function, ahooks will do a special process to ensure that the function called each time is always the latest."),l.a.createElement(s["a"],{code:"const [state, setState] = useState();\n\nuseInterval(() => {\n  console.log(state);\n}, 1000);",lang:"ts"}),l.a.createElement("p",null,"For example, in the above example, the function called by ",l.a.createElement("code",null,"useInterval")," at any time is always the latest, that is, the state is always the latest."),l.a.createElement("h2",{id:"principle"},l.a.createElement(o["AnchorLink"],{to:"#principle","aria-hidden":"true",tabIndex:-1},l.a.createElement("span",{className:"icon icon-link"})),"Principle"),l.a.createElement("p",null,"For the input function, we use ",l.a.createElement("code",null,"useRef")," to make a record to ensure that the latest function can be accessed anywhere."),l.a.createElement(s["a"],{code:"const fnRef = useRef(fn);\nfnRef.current = fn;",lang:"js"}),l.a.createElement("p",null,"For example, the useUnmount code is as follows:"),l.a.createElement(s["a"],{code:"const useUnmount = (fn) => {\n  const fnRef = useRef(fn);\n  fnRef.current = fn;\n\n  useEffect(\n    () => () => {\n      fnRef.current();\n    },\n    [],\n  );\n};",lang:"js"}),l.a.createElement("p",null,"In the above code, because we use ref for memorizing the latest function to solve the closure problem."),l.a.createElement("p",null,"For the output function, we use the ",l.a.createElement(o["Link"],{to:"/zh-CN/hooks/use-memoized-fn"},"useMemoizedFn")," wrapped to ensure that the reference address will never change."),l.a.createElement("p",null,"For a simple example, given a ",l.a.createElement("code",null,"useToggle")," Hook, the code is like this:"),l.a.createElement(s["a"],{code:"const useToggle = (left, right) => {\n  const [state, setState] = useState(left);\n\n  const toggle = useCallback(() => {\n    setState((s) => (s === left ? right : left));\n  }, [left, right]);\n\n  return [state, toggle];\n};",lang:"js"}),l.a.createElement("p",null,"The ",l.a.createElement("code",null,"toggle")," function returned in this demo will change according to the changes of ",l.a.createElement("code",null,"left/right"),", which is uncomfortable for users to use."),l.a.createElement("p",null,"Then we replace ",l.a.createElement("code",null,"useCallback")," with ",l.a.createElement("code",null,"useMemoizedFn")," to realize that the ",l.a.createElement("code",null,"toggle")," reference will never change."),l.a.createElement(s["a"],{code:"const useToggle = (left, right) => {\n  const [state, setState] = useState(left);\n\n  const toggle = useMemoizedFn(() => {\n    setState((s) => (s === left ? right : left));\n  });\n\n  return [state, toggle];\n};",lang:"js"})))}));t["default"]=e=>{var t=l.a.useContext(o["context"]),n=t.demos;return l.a.useEffect((()=>{var t;null!==e&&void 0!==e&&null!==(t=e.location)&&void 0!==t&&t.hash&&o["AnchorLink"].scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),l.a.createElement(c,{demos:n})}}}]);